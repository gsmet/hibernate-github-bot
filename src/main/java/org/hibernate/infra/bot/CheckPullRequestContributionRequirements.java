package org.hibernate.infra.bot;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;

import org.hibernate.infra.bot.config.DeploymentConfig;
import org.hibernate.infra.bot.config.RepositoryConfig;

import org.jboss.logging.Logger;

import io.quarkiverse.githubapp.ConfigFile;
import io.quarkiverse.githubapp.event.PullRequest;
import org.kohsuke.github.GHEventPayload;
import org.kohsuke.github.GHPullRequest;
import org.kohsuke.github.GHPullRequestCommitDetail;

class CheckPullRequestContributionRequirements {

	private static final Logger LOG = Logger.getLogger( CheckPullRequestContributionRequirements.class );

	private static final Pattern SPACE_PATTERN = Pattern.compile( "\\s+" );

	@Inject
	DeploymentConfig deploymentConfig;

	void checkPullRequestEditorialRules(@PullRequest.Opened GHEventPayload.PullRequest pullRequestPayload,
			@ConfigFile("hibernate-github-bot.yml") RepositoryConfig repositoryConfig)
			throws IOException {
		GHPullRequest pullRequest = pullRequestPayload.getPullRequest();

		List<String> errorMessages = new ArrayList<>();
		collectErrorMessages( errorMessages, repositoryConfig, pullRequest );

		if ( errorMessages.isEmpty() ) {
			return;
		}

		StringBuilder comment = new StringBuilder( "Thanks for your pull request!\n\n" +
				"Your pull request does not follow our contribution requirements. Could you have a look?\n\n" );
		for ( String errorMessage : errorMessages ) {
			comment.append( "- " ).append( errorMessage ).append( "\n" );
		}
		comment.append( "\n> This message is automatically generated by a bot." );

		if ( !deploymentConfig.isDryRun() ) {
			pullRequest.comment( comment.toString() );
		}
		else {
			LOG.info( "Pull request #" + pullRequest.getNumber() + " - Add comment " + comment.toString() );
		}
	}

	private static void collectErrorMessages(List<String> errorMessages,
			RepositoryConfig repositoryConfig, GHPullRequest pullRequest) {
		String title = pullRequest.getTitle();

		if ( title == null || title.isEmpty() ) {
			errorMessages.add( "title should not be empty" );
			return;
		}

		if ( title.endsWith( "." ) ) {
			errorMessages.add( "title should not end with a dot" );
		}
		if ( title.endsWith( "â€¦" ) ) {
			errorMessages.add( "title should not end with an ellipsis (make sure the title is complete)" );
		}
		if ( SPACE_PATTERN.split( title.trim() ).length < 2 ) {
			errorMessages.add( "title should count at least 2 words to describe the change properly" );
		}

		if ( repositoryConfig != null && repositoryConfig.jira != null ) {
			repositoryConfig.jira.getIssueKeyPattern()
					.ifPresent( issueKeyPattern -> collectJiraErrorMessages( errorMessages, issueKeyPattern,
							pullRequest ) );
		}
	}

	private static void collectJiraErrorMessages(List<String> errorMessages, Pattern issueKeyPattern,
			GHPullRequest pullRequest) {
		String title = pullRequest.getTitle();
		String body = pullRequest.getBody();

		Set<String> issueKeys = new LinkedHashSet<>();
		Set<String> commitsWithMessageNotStartingWithIssueKey = new LinkedHashSet<>();
		for ( GHPullRequestCommitDetail commitDetails : pullRequest.listCommits() ) {
			GHPullRequestCommitDetail.Commit commit = commitDetails.getCommit();
			String message = commit.getMessage();
			Matcher commitMessageIssueKeyMatcher = issueKeyPattern.matcher( message );
			int issueKeyIndex = commitMessageIssueKeyMatcher.find() ? commitMessageIssueKeyMatcher.start() : -1;
			if ( issueKeyIndex == 0 ) {
				issueKeys.add( commitMessageIssueKeyMatcher.group() );
			}
			else {
				commitsWithMessageNotStartingWithIssueKey.add( commitDetails.getSha() );
			}
		}

		if ( !commitsWithMessageNotStartingWithIssueKey.isEmpty() ) {
			errorMessages.add(
					"all commit messages should start with a JIRA issue key matching pattern '"
							+ issueKeyPattern
							+ "' (offending commits: " + commitsWithMessageNotStartingWithIssueKey + ")"
			);
		}

		List<String> issueKeysNotMentionedInTitle = issueKeys.stream()
				.filter( issueKey -> !title.contains( issueKey ) && !body.contains( issueKey ) )
				.collect( Collectors.toList() );
		if ( !issueKeysNotMentionedInTitle.isEmpty() ) {
			errorMessages.add(
					"all JIRA issues addressed by commits should be mentioned in the PR title or body,"
							+ " preferably using a link"
							+ " (issues not mentioned: " + issueKeysNotMentionedInTitle + ")"
			);
		}
	}
}
